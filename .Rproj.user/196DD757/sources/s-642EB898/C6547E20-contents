QS_calc = function(x, alpha, P, H, R) {
  
  w = min(.75, .25+.025*(P-alpha))
  beta = max (  min(50, 4*H-3*P) , (4*H-P)/3 )
  
  D = P-20          # delay index
  C = (P+50)/2 - H  # control index
  
  knot    = vector("numeric",5)
  knot[1] = alpha
  knot[2] = alpha + w*(P-alpha)
  knot[3] = P
  knot[4] = (P+H)/2
  knot[5] = (H+beta)/2
  
  A      = matrix(NA,5,5)
  target = vector("numeric",5)
  
  # target value at P=1
  A[1,]     = (pmax(P-knot, 0))^2
  target[1] = 1
  
  # target value at H=1/2
  A[2,]     = (pmax(H-knot, 0))^2
  target[2] = 1/2
  
  # target value at beta=0
  A[3,]     = (pmax(beta-knot, 0))^2
  target[3] = 0
  
  # target slope at P=0
  A[4,]     = 2*pmax(P-knot, 0) 
  target[4] = 0
  
  # target slope at beta=0
  A[5,]     = 2*pmax(beta-knot, 0) 
  target[5] = 0
  
  # calculate thetas
  theta = solve(A,target)
  
  tmp = (pmax( outer(x,knot,"-") , 0))^2
  
  y = (x >= alpha) * (x <= beta) * R * (tmp %*% theta)  # ASFRs
  
  delay  = D
  control= C
  
  x  = as.vector(x)
  fx = as.vector(y)
  
  # calculate the a,b,c for each section in  [a x^2 + b x + c] form
  
  
  return(list( x=x, fx=fx, knot=knot, theta=theta, beta=beta))
} #QS


z = QS_calc(seq(10,55,.25), 15, 26, 34, 200)

theta = z$theta
x     = z$x
alpha = 15
P     = 26
H     = 34
R     = 200
beta  = z$beta
knot  = z$knot

aa = R * cumsum( theta )
bb = -2* R * cumsum( theta * knot)
cc = R * cumsum( theta * knot^2)

qf = sapply(x, function(z) aa*z^2 + bb*z + cc) %>% t()

matplot(x,qf, lty=1, type='l', ylim=c(0,R))

yy = sapply(knot, function(z) aa*z^2 + bb*z + cc) %>% diag()

points(c(knot, beta), c(yy,0), cex=2)
